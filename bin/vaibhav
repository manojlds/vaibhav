#!/usr/bin/env bash
# vaibhav - Project session manager for AI coding tools over tmux
# Usage:
#   vaibhav init              - Interactive setup (creates ~/.config/vaibhav/config)
#   vaibhav list              - List all registered projects and active sessions
#   vaibhav <name>            - Attach/create tmux session for a project
#   vaibhav <name> <tool>     - Attach/create session and launch an AI tool
#   vaibhav add <name> <path> - Register a new project
#   vaibhav remove <name>     - Unregister a project
#   vaibhav scan [dir]        - Auto-register all projects under a directory

set -euo pipefail

VAIBHAV_VERSION="0.3.6"

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/vaibhav"
CONFIG_FILE="$CONFIG_DIR/config"
PROJECTS_FILE="$CONFIG_DIR/projects"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# --- Load config if it exists ---
if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
fi

# --- Remote mode: if not on the desktop, SSH in ---
VAIBHAV_DESKTOP_HOST="${VAIBHAV_DESKTOP_HOST:-}"
VAIBHAV_SSH_HOST="${VAIBHAV_SSH_HOST:-desktop}"
VAIBHAV_USE_MOSH="${VAIBHAV_USE_MOSH:-false}"

if [[ -n "$VAIBHAV_DESKTOP_HOST" ]] && [[ "$(hostname)" != "$VAIBHAV_DESKTOP_HOST" ]]; then
    echo -e "${BOLD}vaibhav${NC} ${DIM}v${VAIBHAV_VERSION}${NC}"

    # Check for --mosh flag
    use_mosh="$VAIBHAV_USE_MOSH"
    args=()
    for arg in "$@"; do
        if [[ "$arg" == "--mosh" ]]; then
            use_mosh=true
        else
            args+=("$arg")
        fi
    done
    set -- "${args[@]+"${args[@]}"}"

    case "${1:-}" in
        init|update|setup)
            ;; # init, update, and setup always run locally
        list|ls|help|-h|--help)
            exec ssh "$VAIBHAV_SSH_HOST" "\$SHELL -lic '\$HOME/bin/vaibhav $*'"
            ;;
        *)
            if [[ "$use_mosh" == "true" ]] && command -v mosh &>/dev/null; then
                echo -e "  ${DIM}connecting via mosh...${NC}"
                exec mosh "$VAIBHAV_SSH_HOST" -- bash -lic "\$HOME/bin/vaibhav $*"
            else
                if [[ "$use_mosh" == "true" ]]; then
                    echo -e "  ${YELLOW}!${NC} ${DIM}mosh not found, falling back to ssh${NC}"
                fi
                exec ssh -t "$VAIBHAV_SSH_HOST" "\$SHELL -lic '\$HOME/bin/vaibhav $*'"
            fi
            ;;
    esac
fi

VAIBHAV_PROJECTS_DIR="${VAIBHAV_PROJECTS_DIR:-}"

mkdir -p "$CONFIG_DIR"
touch "$PROJECTS_FILE"

# --- init ---
init_config() {
    echo -e "${BOLD}vaibhav init${NC}"
    echo ""

    local current_projects_dir="${VAIBHAV_PROJECTS_DIR:-}"
    local current_desktop_host="${VAIBHAV_DESKTOP_HOST:-}"
    local current_ssh_host="${VAIBHAV_SSH_HOST:-desktop}"

    # Projects directory
    local default_projects_dir="${current_projects_dir:-$HOME/projects}"
    read -rp "Projects directory [${default_projects_dir}]: " input_projects_dir
    local projects_dir="${input_projects_dir:-$default_projects_dir}"

    # Desktop hostname (for remote mode)
    local default_desktop_host="${current_desktop_host:-$(hostname)}"
    read -rp "Desktop hostname [${default_desktop_host}]: " input_desktop_host
    local desktop_host="${input_desktop_host:-$default_desktop_host}"

    # SSH host alias (for remote mode)
    local default_ssh_host="${current_ssh_host}"
    read -rp "SSH host alias [${default_ssh_host}]: " input_ssh_host
    local ssh_host="${input_ssh_host:-$default_ssh_host}"

    # Mosh (optional)
    local current_use_mosh="${VAIBHAV_USE_MOSH:-false}"
    local default_use_mosh="${current_use_mosh}"
    read -rp "Use mosh by default? [y/N] " input_use_mosh
    local use_mosh="false"
    if [[ "$input_use_mosh" =~ ^[Yy]$ ]]; then
        use_mosh="true"
    fi

    # Write config
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# vaibhav configuration
VAIBHAV_PROJECTS_DIR="${projects_dir}"
VAIBHAV_DESKTOP_HOST="${desktop_host}"
VAIBHAV_SSH_HOST="${ssh_host}"
VAIBHAV_USE_MOSH="${use_mosh}"
EOF

    echo ""
    echo -e "${GREEN}✓${NC} Config saved to ${CYAN}${CONFIG_FILE}${NC}"
    echo ""
    cat "$CONFIG_FILE"

    # Offer to scan projects
    if [[ -d "$projects_dir" ]]; then
        echo ""
        read -rp "Scan ${projects_dir} for projects? [Y/n] " yn
        if [[ ! "$yn" =~ ^[Nn]$ ]]; then
            # Reload config
            source "$CONFIG_FILE"
            scan_projects "$projects_dir"
        fi
    fi
}

get_project_path() {
    local name="$1"
    grep "^${name}=" "$PROJECTS_FILE" 2>/dev/null | cut -d= -f2-
}

list_projects() {
    echo -e "${BOLD}Projects${NC}"
    echo ""

    if [[ ! -s "$PROJECTS_FILE" ]]; then
        echo -e "  ${DIM}No projects registered. Use 'vaibhav add <name> <path>' or 'vaibhav scan'${NC}"
        echo ""
        return
    fi

    # Get active tmux sessions
    local active_sessions=""
    if tmux list-sessions 2>/dev/null >/dev/null; then
        active_sessions=$(tmux list-sessions -F "#{session_name}" 2>/dev/null || true)
    fi

    while IFS='=' read -r name path; do
        [[ -z "$name" || "$name" == \#* ]] && continue

        local status="${DIM}inactive${NC}"
        local indicator=" "
        if echo "$active_sessions" | grep -qx "$name" 2>/dev/null; then
            # Check what windows are running
            local windows
            windows=$(tmux list-windows -t "$name" -F "#{window_name}" 2>/dev/null | tr '\n' ',' | sed 's/,$//')
            status="${GREEN}active${NC} ${DIM}[${windows}]${NC}"
            indicator="${GREEN}●${NC}"
        fi

        # Check for ralph session
        if echo "$active_sessions" | grep -qx "ralph-${name}" 2>/dev/null; then
            status+=" ${YELLOW}ralph running${NC}"
            [[ "$indicator" == " " ]] && indicator="${YELLOW}●${NC}"
        fi

        echo -e "  ${indicator} ${CYAN}${name}${NC} ${DIM}→${NC} ${path}"
        echo -e "    ${status}"
    done < "$PROJECTS_FILE"

    echo ""

    # Show orphan tmux sessions (not in projects file)
    if [[ -n "$active_sessions" ]]; then
        local orphans=""
        while IFS= read -r session; do
            # Skip ralph sessions (shown with their project above)
            local base_name="${session#ralph-}"
            if [[ "$base_name" != "$session" ]] && grep -q "^${base_name}=" "$PROJECTS_FILE" 2>/dev/null; then
                continue
            fi
            if ! grep -q "^${session}=" "$PROJECTS_FILE" 2>/dev/null; then
                orphans+="  ${YELLOW}?${NC} ${session}\n"
            fi
        done <<< "$active_sessions"
        if [[ -n "$orphans" ]]; then
            echo -e "${BOLD}Other tmux sessions${NC}"
            echo ""
            echo -e "$orphans"
        fi
    fi
}

add_project() {
    local name="$1"
    local path="$2"

    # Resolve to absolute path
    path=$(cd "$path" 2>/dev/null && pwd)

    if [[ ! -d "$path" ]]; then
        echo -e "${RED}Error:${NC} Directory does not exist: $path"
        exit 1
    fi

    # Remove existing entry if any
    if grep -q "^${name}=" "$PROJECTS_FILE" 2>/dev/null; then
        sed -i "/^${name}=/d" "$PROJECTS_FILE"
        echo -e "${YELLOW}Updated${NC} ${CYAN}${name}${NC} → ${path}"
    else
        echo -e "${GREEN}Added${NC} ${CYAN}${name}${NC} → ${path}"
    fi

    echo "${name}=${path}" >> "$PROJECTS_FILE"
    # Sort the file for consistency
    sort -o "$PROJECTS_FILE" "$PROJECTS_FILE"
}

remove_project() {
    local name="$1"

    if ! grep -q "^${name}=" "$PROJECTS_FILE" 2>/dev/null; then
        echo -e "${RED}Error:${NC} Project '${name}' not found"
        exit 1
    fi

    sed -i "/^${name}=/d" "$PROJECTS_FILE"
    echo -e "${RED}Removed${NC} ${CYAN}${name}${NC}"

    # Kill tmux session if active
    if tmux has-session -t "$name" 2>/dev/null; then
        read -rp "Kill active tmux session '$name'? [y/N] " yn
        if [[ "$yn" =~ ^[Yy]$ ]]; then
            tmux kill-session -t "$name"
            echo -e "  ${DIM}Session killed${NC}"
        fi
    fi
}

scan_projects() {
    local scan_dir="${1:-${VAIBHAV_PROJECTS_DIR:-$HOME/projects}}"
    scan_dir=$(cd "$scan_dir" 2>/dev/null && pwd)

    echo -e "${BOLD}Scanning${NC} ${scan_dir} ..."
    echo ""

    local count=0
    for dir in "$scan_dir"/*/; do
        [[ ! -d "$dir" ]] && continue
        local name
        name=$(basename "$dir")

        # Skip hidden directories
        [[ "$name" == .* ]] && continue

        if ! grep -q "^${name}=" "$PROJECTS_FILE" 2>/dev/null; then
            echo "${name}=${dir%/}" >> "$PROJECTS_FILE"
            echo -e "  ${GREEN}+${NC} ${CYAN}${name}${NC} → ${dir%/}"
            count=$((count + 1))
        else
            echo -e "  ${DIM}skip${NC} ${name} (already registered)"
        fi
    done

    sort -o "$PROJECTS_FILE" "$PROJECTS_FILE"
    echo ""
    echo -e "${count} project(s) added"
}

open_project() {
    local name="$1"
    local tool="${2:-}"

    local path
    path=$(get_project_path "$name")

    if [[ -z "$path" ]]; then
        echo -e "${RED}Error:${NC} Project '${name}' not found"
        echo -e "${DIM}Run 'vaibhav list' to see registered projects, or 'vaibhav add ${name} /path/to/project'${NC}"
        exit 1
    fi

    if [[ ! -d "$path" ]]; then
        echo -e "${RED}Error:${NC} Project directory does not exist: $path"
        exit 1
    fi

    # Validate tool if specified
    if [[ -n "$tool" ]]; then
        if ! command -v "$tool" &>/dev/null; then
            echo -e "${RED}Error:${NC} Tool '${tool}' not found in PATH"
            exit 1
        fi
    fi

    # Create or attach to tmux session
    if tmux has-session -t "$name" 2>/dev/null; then
        # Session exists
        if [[ -n "$tool" ]]; then
            # Create a new window for the tool if not already running
            local tool_window="${tool}"
            if tmux list-windows -t "$name" -F "#{window_name}" | grep -qx "$tool_window"; then
                # Tool window exists, select it
                tmux select-window -t "${name}:${tool_window}"
            else
                # Create new window with the tool
                tmux new-window -t "$name" -n "$tool_window" -c "$path" "$tool"
            fi
        fi

        # Attach or switch
        if [[ -n "${TMUX:-}" ]]; then
            tmux switch-client -t "$name"
        else
            tmux attach-session -t "$name"
        fi
    else
        # Create new session
        if [[ -n "$tool" ]]; then
            # Create session with tool in first window
            tmux new-session -d -s "$name" -c "$path" -n "$tool" "$tool"
            # Add a shell window
            tmux new-window -t "$name" -n "shell" -c "$path"
            # Go back to tool window
            tmux select-window -t "${name}:${tool}"
        else
            # Create session with shell
            tmux new-session -d -s "$name" -c "$path" -n "shell"
        fi

        # Attach or switch
        if [[ -n "${TMUX:-}" ]]; then
            tmux switch-client -t "$name"
        else
            tmux attach-session -t "$name"
        fi
    fi
}

step() { echo -e "\n${CYAN}▶${NC} ${BOLD}$1${NC}"; }
ok() { echo -e "  ${GREEN}✓${NC} $1"; }
skip() { echo -e "  ${DIM}skip${NC} $1"; }

# --- setup (Termux environment sync) ---
# Idempotent, non-interactive in --post-update mode
# Ensures Termux-side packages and config are up to date
setup_termux() {
    local post_update=false
    for arg in "$@"; do
        [[ "$arg" == "--post-update" ]] && post_update=true
    done

    if [[ "$post_update" == "false" ]]; then
        echo -e "${BOLD}vaibhav setup${NC}"
    fi

    # --- openssh ---
    step "Checking openssh"
    if command -v ssh &>/dev/null; then
        ok "openssh installed"
    else
        pkg install -y openssh
        ok "openssh installed"
    fi

    # --- mosh ---
    step "Checking mosh"
    local mosh_just_installed=false
    if command -v mosh &>/dev/null; then
        ok "mosh already installed"
    elif [[ "${VAIBHAV_USE_MOSH:-false}" == "true" ]]; then
        pkg install -y mosh
        ok "mosh installed (VAIBHAV_USE_MOSH=true)"
        mosh_just_installed=true
    else
        # Check if desktop has mosh-server
        local desktop_has_mosh=false
        if [[ -n "${VAIBHAV_SSH_HOST:-}" ]] && ssh -o BatchMode=yes -o ConnectTimeout=5 "$VAIBHAV_SSH_HOST" "command -v mosh-server" &>/dev/null; then
            desktop_has_mosh=true
        fi

        if [[ "$desktop_has_mosh" == "true" ]]; then
            echo -e "  ${DIM}Desktop has mosh-server — installing mosh client...${NC}"
            pkg install -y mosh
            ok "mosh installed (desktop has mosh-server)"
            mosh_just_installed=true
        elif [[ "$post_update" == "false" ]]; then
            read -rp "  Install mosh for resilient mobile connections? [y/N] " yn </dev/tty
            if [[ "$yn" =~ ^[Yy]$ ]]; then
                pkg install -y mosh
                ok "mosh installed"
                mosh_just_installed=true
            else
                skip "mosh (install later with: pkg install mosh)"
            fi
        else
            skip "mosh not installed"
        fi
    fi

    # Offer to enable mosh if installed but not enabled
    if command -v mosh &>/dev/null && [[ "${VAIBHAV_USE_MOSH:-false}" != "true" ]]; then
        if [[ "$mosh_just_installed" == "true" ]] || [[ "$post_update" == "false" ]]; then
            echo ""
            read -rp "  Enable mosh by default? (use mosh for all connections) [Y/n] " yn </dev/tty
            if [[ ! "$yn" =~ ^[Nn]$ ]]; then
                if [[ -f "$CONFIG_FILE" ]] && grep -q '^VAIBHAV_USE_MOSH=' "$CONFIG_FILE"; then
                    sed -i 's/^VAIBHAV_USE_MOSH=.*/VAIBHAV_USE_MOSH="true"/' "$CONFIG_FILE"
                else
                    echo 'VAIBHAV_USE_MOSH="true"' >> "$CONFIG_FILE"
                fi
                VAIBHAV_USE_MOSH="true"
                ok "mosh enabled (VAIBHAV_USE_MOSH=true)"
            else
                ok "mosh installed but not enabled (use --mosh flag per connection)"
            fi
        fi
    fi

    # --- vaibhav-ralph ---
    step "Checking vaibhav-ralph"
    if [[ -x "$HOME/bin/vaibhav-ralph" ]]; then
        ok "vaibhav-ralph installed"
    else
        echo -e "  ${DIM}Downloading vaibhav-ralph...${NC}"
        local ralph_url="https://raw.githubusercontent.com/manojlds/vaibhav/main/bin/vaibhav-ralph"
        if curl -fsSL "$ralph_url" -o "$HOME/bin/vaibhav-ralph"; then
            chmod +x "$HOME/bin/vaibhav-ralph"
            ok "vaibhav-ralph installed"
        else
            echo -e "  ${YELLOW}!${NC} Failed to download vaibhav-ralph (non-fatal)"
        fi
    fi

    # --- Shell PATH ---
    step "Checking PATH"
    local shell_rc="$HOME/.bashrc"
    if [[ -f "$HOME/.zshrc" ]]; then
        shell_rc="$HOME/.zshrc"
    fi

    if grep -q 'PATH=.*\$HOME/bin' "$shell_rc" 2>/dev/null; then
        ok "PATH already configured in $shell_rc"
    else
        cat >> "$shell_rc" << 'PATHBLOCK'

# vaibhav
export PATH="$HOME/bin:$PATH"
PATHBLOCK
        ok "PATH configured in $shell_rc"
    fi

    # --- Termux extra keys ---
    step "Checking Termux keyboard"
    if [[ -d "$HOME/.termux" ]] || command -v termux-info &>/dev/null; then
        mkdir -p ~/.termux
        if [[ ! -f ~/.termux/termux.properties ]]; then
            cat > ~/.termux/termux.properties << 'PROPS'
# Extra keys row for tmux and coding
extra-keys = [ \
  ['ESC', 'CTRL', 'ALT', 'TAB', '|', '-', 'UP', 'DOWN'] \
]
PROPS
            ok "Extra keyboard row configured"
        elif grep -q "extra-keys" ~/.termux/termux.properties 2>/dev/null; then
            ok "Extra keys already configured"
        else
            echo '' >> ~/.termux/termux.properties
            cat >> ~/.termux/termux.properties << 'PROPS'
# Extra keys row for tmux and coding
extra-keys = [ \
  ['ESC', 'CTRL', 'ALT', 'TAB', '|', '-', 'UP', 'DOWN'] \
]
PROPS
            ok "Extra keyboard row added"
        fi
    else
        skip "not running in Termux"
    fi

    # --- Font (interactive only) ---
    if [[ "$post_update" == "false" ]] && command -v termux-info &>/dev/null; then
        step "Font setup"
        if [[ -f ~/.termux/font.ttf ]]; then
            ok "Custom font already installed"
        else
            read -rp "Install FiraCode Nerd Font? (recommended for icons) [Y/n] " yn </dev/tty
            if [[ ! "$yn" =~ ^[Nn]$ ]]; then
                curl -fsSL "https://github.com/ryanoasis/nerd-fonts/raw/HEAD/patched-fonts/FiraCode/Regular/FiraCodeNerdFont-Regular.ttf" -o ~/.termux/font.ttf
                ok "FiraCode Nerd Font installed"
                termux-reload-settings 2>/dev/null || true
            else
                skip "font"
            fi
        fi
    fi

    echo ""
    echo -e "${GREEN}✓${NC} Setup complete"
}

GITHUB_REPO="manojlds/vaibhav"
GITHUB_RELEASES_BASE="https://github.com/${GITHUB_REPO}/releases"

update_termux() {
    local old_version="$VAIBHAV_VERSION"

    local tmp_dir
    tmp_dir=$(mktemp -d)
    trap 'rm -rf "'"$tmp_dir"'"' EXIT

    echo -e "${DIM}Checking for updates...${NC}"

    local latest_tag
    latest_tag=$(curl -fsSL "https://api.github.com/repos/${GITHUB_REPO}/releases/latest" | sed -n 's/.*"tag_name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    if [[ -z "$latest_tag" ]]; then
        echo -e "${RED}Error:${NC} Failed to determine latest release tag"
        return 1
    fi

    local remote_version="${latest_tag#v}"

    if [[ "$remote_version" == "$old_version" ]]; then
        echo -e "Already up to date (v${old_version})"
        return 0
    fi

    local download_base="${GITHUB_RELEASES_BASE}/download/${latest_tag}"

    if ! curl -fsSL "${download_base}/vaibhav" -o "$tmp_dir/vaibhav"; then
        echo -e "${RED}Error:${NC} Failed to download vaibhav"
        return 1
    fi

    if ! curl -fsSL "${download_base}/vaibhav-ralph" -o "$tmp_dir/vaibhav-ralph"; then
        echo -e "${RED}Error:${NC} Failed to download vaibhav-ralph"
        return 1
    fi

    if ! curl -fsSL "${download_base}/checksums.sha256" -o "$tmp_dir/checksums.sha256"; then
        echo -e "${RED}Error:${NC} Failed to download checksums.sha256"
        return 1
    fi

    mkdir -p "$tmp_dir/verify/bin"
    cp "$tmp_dir/vaibhav" "$tmp_dir/verify/bin/vaibhav"
    cp "$tmp_dir/vaibhav-ralph" "$tmp_dir/verify/bin/vaibhav-ralph"

    local checksum_ok=true
    while read -r expected_hash filepath; do
        case "$filepath" in
            bin/*) ;;
            *) continue ;;
        esac
        local actual_hash
        actual_hash=$(sha256sum "$tmp_dir/verify/$filepath" | cut -d' ' -f1)
        if [[ "$expected_hash" != "$actual_hash" ]]; then
            echo -e "${RED}Error:${NC} Checksum verification failed for $filepath"
            echo -e "  Expected: ${expected_hash}"
            echo -e "  Got:      ${actual_hash}"
            checksum_ok=false
        fi
    done < "$tmp_dir/checksums.sha256"

    if [[ "$checksum_ok" != "true" ]]; then
        echo -e "${RED}Update aborted:${NC} Checksum verification failed. Existing files unchanged."
        return 1
    fi

    # Stage in ~/bin so mv is same-filesystem (atomic rename, preserves old inode)
    # cp would overwrite inode contents while bash is still reading this script
    cp "$tmp_dir/vaibhav" "$HOME/bin/vaibhav.new"
    chmod +x "$HOME/bin/vaibhav.new"
    mv -f "$HOME/bin/vaibhav.new" "$HOME/bin/vaibhav"
    cp "$tmp_dir/vaibhav-ralph" "$HOME/bin/vaibhav-ralph.new"
    chmod +x "$HOME/bin/vaibhav-ralph.new"
    mv -f "$HOME/bin/vaibhav-ralph.new" "$HOME/bin/vaibhav-ralph"

    echo -e "${GREEN}✓${NC} Updated: v${old_version} → v${remote_version}"
    return 0
}

update_desktop_remote() {
    # SSH to the desktop and run git pull in the vaibhav repo
    echo ""
    echo -e "${DIM}Updating desktop via SSH...${NC}"

    # Discover the repo path on the desktop via readlink
    local remote_repo
    if ! remote_repo=$(ssh "$VAIBHAV_SSH_HOST" 'repo=$(dirname "$(dirname "$(readlink -f "$HOME/bin/vaibhav")")") && echo "$repo"' 2>/dev/null); then
        echo -e "${YELLOW}Warning:${NC} Could not connect to desktop via SSH — skipping desktop update"
        return 0
    fi

    if [[ -z "$remote_repo" ]]; then
        echo -e "${YELLOW}Warning:${NC} Could not resolve vaibhav repo path on desktop — skipping desktop update"
        return 0
    fi

    # Get the old version on the desktop before pulling
    local desktop_old_version
    desktop_old_version=$(ssh "$VAIBHAV_SSH_HOST" "grep '^VAIBHAV_VERSION=' '$remote_repo/bin/vaibhav' | cut -d'\"' -f2" 2>/dev/null) || desktop_old_version="unknown"

    # Check for local changes on desktop
    if ! ssh "$VAIBHAV_SSH_HOST" "git -C '$remote_repo' diff --quiet 2>/dev/null && git -C '$remote_repo' diff --cached --quiet 2>/dev/null" 2>/dev/null; then
        echo -e "${YELLOW}Warning:${NC} Desktop has local changes — skipping desktop update"
        return 0
    fi

    # Run git pull on the desktop
    local pull_output
    if ! pull_output=$(ssh "$VAIBHAV_SSH_HOST" "git -C '$remote_repo' fetch origin && git -C '$remote_repo' checkout main && git -C '$remote_repo' pull origin main" 2>&1); then
        echo -e "${YELLOW}Warning:${NC} Desktop git pull failed — skipping"
        echo -e "  ${DIM}${pull_output}${NC}"
        return 0
    fi

    if echo "$pull_output" | grep -q "Already up to date"; then
        echo -e "${GREEN}✓${NC} Desktop already up to date (v${desktop_old_version})"
    else
        local desktop_new_version
        desktop_new_version=$(ssh "$VAIBHAV_SSH_HOST" "grep '^VAIBHAV_VERSION=' '$remote_repo/bin/vaibhav' | cut -d'\"' -f2" 2>/dev/null) || desktop_new_version="unknown"
        echo -e "${GREEN}✓${NC} Desktop updated: v${desktop_old_version} → v${desktop_new_version}"
    fi
    return 0
}

update_desktop() {
    # Resolve repo directory from the symlink at ~/bin/vaibhav
    local vaibhav_bin
    vaibhav_bin=$(readlink -f "$HOME/bin/vaibhav")
    if [[ -z "$vaibhav_bin" || ! -f "$vaibhav_bin" ]]; then
        echo -e "${RED}Error:${NC} Cannot resolve vaibhav installation path from ~/bin/vaibhav"
        return 1
    fi
    # Two levels up: bin/vaibhav -> bin/ -> repo root
    local repo_dir
    repo_dir=$(cd "$(dirname "$vaibhav_bin")/.." && pwd)

    if [[ ! -d "$repo_dir/.git" ]]; then
        echo -e "${RED}Error:${NC} Not a git repository: $repo_dir"
        return 1
    fi

    local old_version="$VAIBHAV_VERSION"

    # Check for local changes that would conflict with pull
    if ! git -C "$repo_dir" diff --quiet 2>/dev/null || ! git -C "$repo_dir" diff --cached --quiet 2>/dev/null; then
        echo -e "${YELLOW}Warning:${NC} Local changes detected in $repo_dir"
        echo -e "  ${DIM}Commit or stash your changes before updating.${NC}"
        return 1
    fi

    # Run git pull
    local pull_output
    pull_output=$(git -C "$repo_dir" checkout main && git -C "$repo_dir" pull origin main 2>&1) || {
        echo -e "${RED}Error:${NC} git pull failed"
        echo "$pull_output"
        return 1
    }

    # Check if already up to date
    if echo "$pull_output" | grep -q "Already up to date"; then
        echo -e "Already up to date (v${old_version})"
        return 0
    fi

    # Source the new version
    local new_version
    new_version=$(grep '^VAIBHAV_VERSION=' "$vaibhav_bin" | cut -d'"' -f2)

    echo -e "${GREEN}✓${NC} Updated: v${old_version} → v${new_version}"
    return 0
}

show_usage() {
    echo -e "${BOLD}vaibhav${NC} ${DIM}v${VAIBHAV_VERSION}${NC} — Project session manager for AI coding tools"
    echo ""
    echo -e "${BOLD}Usage:${NC}"
    echo "  vaibhav init                Interactive setup"
    echo "  vaibhav list                List all projects and active sessions"
    echo "  vaibhav <name>              Open a project in tmux"
    echo "  vaibhav <name> <tool>       Open a project with an AI tool (amp, claude, codex, opencode)"
    echo "  vaibhav <name> --mosh       Open a project using mosh (resilient connection)"
    echo "  vaibhav <name> <tool> --mosh  Open with an AI tool via mosh"
    echo "  vaibhav add <name> <path>   Register a new project"
    echo "  vaibhav remove <name>       Unregister a project"
    echo "  vaibhav scan [dir]          Auto-register projects under a directory"
    echo "  vaibhav setup               Set up Termux environment (packages, config)"
    echo "  vaibhav update              Update vaibhav to the latest version"
    echo "  vaibhav ralph ...           Ralph loop utility (run 'vaibhav ralph help' for details)"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  vaibhav init                First-time setup"
    echo "  vaibhav heimdall amp        Open heimdall project with Amp"
    echo "  vaibhav scan ~/projects     Register all projects under ~/projects"
    echo "  vaibhav ralph init          Setup ralph config for current project"
    echo ""
    echo -e "${BOLD}Config:${NC} ${CONFIG_FILE}"
}

# Main dispatch
case "${1:-}" in
    ""|help|-h|--help)
        show_usage
        ;;
    version|-v|--version)
        echo "vaibhav $VAIBHAV_VERSION"
        ;;
    init)
        init_config
        ;;
    list|ls)
        list_projects
        ;;
    add)
        if [[ $# -lt 3 ]]; then
            echo -e "${RED}Usage:${NC} vaibhav add <name> <path>"
            exit 1
        fi
        add_project "$2" "$3"
        ;;
    remove|rm)
        if [[ $# -lt 2 ]]; then
            echo -e "${RED}Usage:${NC} vaibhav remove <name>"
            exit 1
        fi
        remove_project "$2"
        ;;
    scan)
        scan_projects "${2:-}"
        ;;
    setup)
        setup_termux "${@:2}"
        ;;
    update)
        if [[ -n "$VAIBHAV_DESKTOP_HOST" ]] && [[ "$(hostname)" != "$VAIBHAV_DESKTOP_HOST" ]]; then
            update_termux
            # Run setup with the newly updated vaibhav to apply any new setup steps
            "$HOME/bin/vaibhav" setup --post-update || true
            # Also update desktop unless --local flag is set
            skip_desktop=false
            for arg in "$@"; do
                [[ "$arg" == "--local" ]] && skip_desktop=true
            done
            if [[ "$skip_desktop" == "false" ]]; then
                update_desktop_remote
            fi
        else
            update_desktop
        fi
        ;;
    ralph)
        shift
        SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0")")" && pwd)"
        exec "$SCRIPT_DIR/vaibhav-ralph" "$@"
        ;;
    *)
        open_project "$1" "${2:-}"
        ;;
esac
