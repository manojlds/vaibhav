#!/usr/bin/env bash
# vaibhav-ralph - Ralph loop utility for AI-driven development
# Usage:
#   vaibhav ralph init [dir]          - Auto-detect project and create .vaibhav/config.yaml
#   vaibhav ralph add-rule "rule"     - Add a rule to the project config
#   vaibhav ralph config              - Show current project config
#   vaibhav ralph status              - Show PRD progress

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

RALPH_CONFIG_DIR=".vaibhav"
RALPH_CONFIG_FILE="$RALPH_CONFIG_DIR/config.yaml"

VAIBHAV_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/vaibhav"
VAIBHAV_PROJECTS_FILE="$VAIBHAV_CONFIG_DIR/projects"

# --- Resolve --project / -p flag ---
# Allows running ralph commands from anywhere (e.g., phone) by specifying a project name
resolve_project_flag() {
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--project)
                local project_name="$2"
                shift 2
                local project_path
                project_path=$(grep "^${project_name}=" "$VAIBHAV_PROJECTS_FILE" 2>/dev/null | cut -d= -f2- || true)
                if [[ -z "$project_path" ]]; then
                    echo -e "${RED}Error:${NC} Project '${project_name}' not found in registry" >&2
                    echo -e "${DIM}Run 'vaibhav list' to see registered projects${NC}" >&2
                    exit 1
                fi
                if [[ ! -d "$project_path" ]]; then
                    echo -e "${RED}Error:${NC} Project directory does not exist: $project_path" >&2
                    exit 1
                fi
                cd "$project_path"
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    # Return remaining args
    RALPH_ARGS=("${args[@]+"${args[@]}"}")
}

resolve_project_flag "$@"
set -- "${RALPH_ARGS[@]+"${RALPH_ARGS[@]}"}"

# --- Detect project language and framework ---
detect_project() {
    local dir="$1"

    local language=""
    local framework=""
    local cmd_test=""
    local cmd_lint=""
    local cmd_build=""
    local cmd_typecheck=""

    # Node.js / TypeScript
    if [[ -f "$dir/package.json" ]]; then
        # Check for TypeScript
        if [[ -f "$dir/tsconfig.json" ]] || grep -q '"typescript"' "$dir/package.json" 2>/dev/null; then
            language="TypeScript"
        else
            language="JavaScript"
        fi

        # Detect framework from dependencies
        if grep -q '"next"' "$dir/package.json" 2>/dev/null; then
            framework="Next.js"
        elif grep -q '"nuxt"' "$dir/package.json" 2>/dev/null; then
            framework="Nuxt"
        elif grep -q '"@angular/core"' "$dir/package.json" 2>/dev/null; then
            framework="Angular"
        elif grep -q '"svelte"' "$dir/package.json" 2>/dev/null; then
            framework="SvelteKit"
        elif grep -q '"react"' "$dir/package.json" 2>/dev/null; then
            framework="React"
        elif grep -q '"vue"' "$dir/package.json" 2>/dev/null; then
            framework="Vue"
        elif grep -q '"express"' "$dir/package.json" 2>/dev/null; then
            framework="Express"
        elif grep -q '"fastify"' "$dir/package.json" 2>/dev/null; then
            framework="Fastify"
        elif grep -q '"nestjs"' "$dir/package.json" 2>/dev/null || grep -q '"@nestjs/core"' "$dir/package.json" 2>/dev/null; then
            framework="NestJS"
        fi

        # Extract scripts from package.json
        cmd_test=$(extract_npm_script "$dir" "test")
        cmd_lint=$(extract_npm_script "$dir" "lint")
        cmd_build=$(extract_npm_script "$dir" "build")

        # Typecheck
        if [[ "$language" == "TypeScript" ]]; then
            local tc_script
            tc_script=$(extract_npm_script "$dir" "typecheck")
            if [[ -z "$tc_script" ]]; then
                tc_script=$(extract_npm_script "$dir" "type-check")
            fi
            if [[ -n "$tc_script" ]]; then
                cmd_typecheck="$tc_script"
            else
                cmd_typecheck="npx tsc --noEmit"
            fi
        fi

    # Python
    elif [[ -f "$dir/pyproject.toml" ]] || [[ -f "$dir/requirements.txt" ]] || [[ -f "$dir/setup.py" ]]; then
        language="Python"

        if [[ -f "$dir/pyproject.toml" ]]; then
            if grep -q 'fastapi' "$dir/pyproject.toml" 2>/dev/null; then
                framework="FastAPI"
            elif grep -q 'django' "$dir/pyproject.toml" 2>/dev/null; then
                framework="Django"
            elif grep -q 'flask' "$dir/pyproject.toml" 2>/dev/null; then
                framework="Flask"
            fi
        fi

        # Common python commands
        if [[ -f "$dir/pyproject.toml" ]] && grep -q 'pytest' "$dir/pyproject.toml" 2>/dev/null; then
            cmd_test="pytest"
        elif [[ -d "$dir/tests" ]]; then
            cmd_test="pytest"
        fi

        if command -v ruff &>/dev/null || grep -q 'ruff' "$dir/pyproject.toml" 2>/dev/null; then
            cmd_lint="ruff check ."
        elif command -v flake8 &>/dev/null; then
            cmd_lint="flake8 ."
        fi

        if grep -q 'mypy' "$dir/pyproject.toml" 2>/dev/null; then
            cmd_typecheck="mypy ."
        fi

    # Go
    elif [[ -f "$dir/go.mod" ]]; then
        language="Go"

        if grep -q 'gin-gonic' "$dir/go.mod" 2>/dev/null; then
            framework="Gin"
        elif grep -q 'labstack/echo' "$dir/go.mod" 2>/dev/null; then
            framework="Echo"
        elif grep -q 'gofiber' "$dir/go.mod" 2>/dev/null; then
            framework="Fiber"
        fi

        cmd_test="go test ./..."
        cmd_lint="golangci-lint run"
        cmd_build="go build ./..."

    # Rust
    elif [[ -f "$dir/Cargo.toml" ]]; then
        language="Rust"

        if grep -q 'actix-web' "$dir/Cargo.toml" 2>/dev/null; then
            framework="Actix"
        elif grep -q 'axum' "$dir/Cargo.toml" 2>/dev/null; then
            framework="Axum"
        elif grep -q 'rocket' "$dir/Cargo.toml" 2>/dev/null; then
            framework="Rocket"
        fi

        cmd_test="cargo test"
        cmd_lint="cargo clippy"
        cmd_build="cargo build"

    # Java / Kotlin
    elif [[ -f "$dir/pom.xml" ]]; then
        language="Java"
        framework="Maven"
        cmd_test="mvn test"
        cmd_build="mvn package"
    elif [[ -f "$dir/build.gradle" ]] || [[ -f "$dir/build.gradle.kts" ]]; then
        if [[ -f "$dir/build.gradle.kts" ]]; then
            language="Kotlin"
        else
            language="Java"
        fi
        framework="Gradle"
        cmd_test="./gradlew test"
        cmd_build="./gradlew build"

    # Bash / Shell
    elif compgen -G "$dir/bin/*" > /dev/null 2>&1 || compgen -G "$dir/*.sh" > /dev/null 2>&1; then
        local has_bash=false
        for f in "$dir"/bin/* "$dir"/*.sh; do
            [[ -f "$f" ]] && head -1 "$f" 2>/dev/null | grep -q 'bash' && has_bash=true && break
        done
        if [[ "$has_bash" == "true" ]]; then
            language="Bash"
            if command -v shellcheck &>/dev/null; then
                # Collect script paths for shellcheck
                local scripts=""
                for f in "$dir"/bin/* "$dir"/*.sh; do
                    [[ -f "$f" ]] && scripts+=" $(basename "$f")"
                done
                cmd_lint="shellcheck${scripts}"
            fi
        fi

    # Ruby
    elif [[ -f "$dir/Gemfile" ]]; then
        language="Ruby"
        if grep -q 'rails' "$dir/Gemfile" 2>/dev/null; then
            framework="Rails"
            cmd_test="bundle exec rails test"
        else
            cmd_test="bundle exec rspec"
        fi
        cmd_lint="bundle exec rubocop"
    fi

    # Return results via global vars
    DETECTED_LANGUAGE="$language"
    DETECTED_FRAMEWORK="$framework"
    DETECTED_CMD_TEST="$cmd_test"
    DETECTED_CMD_LINT="$cmd_lint"
    DETECTED_CMD_BUILD="$cmd_build"
    DETECTED_CMD_TYPECHECK="$cmd_typecheck"
}

# Extract an npm script name, returning the `npm run <name>` command if found
extract_npm_script() {
    local dir="$1"
    local script_name="$2"

    if grep -q "\"${script_name}\"" "$dir/package.json" 2>/dev/null; then
        # Check if it's in the "scripts" section
        if python3 -c "
import json, sys
with open('$dir/package.json') as f:
    pkg = json.load(f)
scripts = pkg.get('scripts', {})
if '$script_name' in scripts:
    print('npm run $script_name')
" 2>/dev/null; then
            return
        fi
        # Fallback: simple grep
        echo "npm run $script_name"
    fi
}

# --- Write config.yaml ---
write_config() {
    local dir="$1"
    local project_name
    project_name=$(basename "$dir")

    mkdir -p "$dir/$RALPH_CONFIG_DIR"

    {
        echo "# vaibhav ralph configuration"
        echo "# Auto-generated — edit as needed"
        echo ""
        echo "project:"
        echo "  name: \"$project_name\""
        if [[ -n "$DETECTED_LANGUAGE" ]]; then
            echo "  language: \"$DETECTED_LANGUAGE\""
        fi
        if [[ -n "$DETECTED_FRAMEWORK" ]]; then
            echo "  framework: \"$DETECTED_FRAMEWORK\""
        fi
        echo ""
        echo "commands:"
        if [[ -n "$DETECTED_CMD_TEST" ]]; then
            echo "  test: \"$DETECTED_CMD_TEST\""
        else
            echo "  # test: \"\""
        fi
        if [[ -n "$DETECTED_CMD_LINT" ]]; then
            echo "  lint: \"$DETECTED_CMD_LINT\""
        else
            echo "  # lint: \"\""
        fi
        if [[ -n "$DETECTED_CMD_BUILD" ]]; then
            echo "  build: \"$DETECTED_CMD_BUILD\""
        else
            echo "  # build: \"\""
        fi
        if [[ -n "$DETECTED_CMD_TYPECHECK" ]]; then
            echo "  typecheck: \"$DETECTED_CMD_TYPECHECK\""
        fi
        echo ""
        echo "rules: []"
        echo "  # - \"follow existing patterns\""
        echo "  # - \"use TypeScript strict mode\""
        echo ""
        echo "boundaries:"
        echo "  never_touch:"
        echo "    - \"*.lock\""
        echo "    - \".env*\""
        echo ""
        echo "engine: \"amp\"  # amp, claude, opencode"
        echo "max_retries: 3"
    } > "$dir/$RALPH_CONFIG_FILE"
}

# --- Init command ---
ralph_init() {
    local dir="${1:-$(pwd)}"
    dir=$(cd "$dir" 2>/dev/null && pwd)

    echo -e "${BOLD}vaibhav ralph init${NC}"
    echo -e "${DIM}Scanning ${dir}${NC}"
    echo ""

    local existing_config=""
    if [[ -f "$dir/$RALPH_CONFIG_FILE" ]]; then
        existing_config="$dir/$RALPH_CONFIG_FILE"
        echo -e "  ${DIM}Existing config found — will preserve rules, boundaries, and engine${NC}"
        echo ""
    fi

    # Detect project
    detect_project "$dir"

    # Show detection results
    if [[ -n "$DETECTED_LANGUAGE" ]]; then
        echo -e "  ${GREEN}✓${NC} Language:   ${CYAN}${DETECTED_LANGUAGE}${NC}"
    else
        echo -e "  ${YELLOW}?${NC} Language:   ${DIM}not detected${NC}"
    fi

    if [[ -n "$DETECTED_FRAMEWORK" ]]; then
        echo -e "  ${GREEN}✓${NC} Framework:  ${CYAN}${DETECTED_FRAMEWORK}${NC}"
    fi

    if [[ -n "$DETECTED_CMD_TEST" ]]; then
        echo -e "  ${GREEN}✓${NC} Test:       ${CYAN}${DETECTED_CMD_TEST}${NC}"
    else
        echo -e "  ${DIM}  Test:       not detected${NC}"
    fi

    if [[ -n "$DETECTED_CMD_LINT" ]]; then
        echo -e "  ${GREEN}✓${NC} Lint:       ${CYAN}${DETECTED_CMD_LINT}${NC}"
    else
        echo -e "  ${DIM}  Lint:       not detected${NC}"
    fi

    if [[ -n "$DETECTED_CMD_BUILD" ]]; then
        echo -e "  ${GREEN}✓${NC} Build:      ${CYAN}${DETECTED_CMD_BUILD}${NC}"
    else
        echo -e "  ${DIM}  Build:      not detected${NC}"
    fi

    if [[ -n "$DETECTED_CMD_TYPECHECK" ]]; then
        echo -e "  ${GREEN}✓${NC} Typecheck:  ${CYAN}${DETECTED_CMD_TYPECHECK}${NC}"
    fi

    echo ""

    # Preserve or ask for engine
    local engine="amp"
    if [[ -n "$existing_config" ]]; then
        engine=$(read_config_value "$existing_config" "engine")
        engine="${engine:-amp}"
        echo -e "  ${DIM}Engine:     ${engine} (preserved)${NC}"
    else
        echo -e "  ${BOLD}Default AI engine:${NC}"
        echo -e "    1) amp"
        echo -e "    2) claude"
        echo -e "    3) opencode"
        read -rp "  Choose [1]: " engine_choice
        case "${engine_choice:-1}" in
            2) engine="claude" ;;
            3) engine="opencode" ;;
            *) engine="amp" ;;
        esac
    fi

    # Save old config before overwriting
    local old_config_tmp=""
    if [[ -n "$existing_config" ]]; then
        old_config_tmp=$(mktemp)
        cp "$existing_config" "$old_config_tmp"
    fi

    # Write fresh config with detected values, then merge preserved fields
    write_config "$dir"

    if [[ -n "$existing_config" ]]; then
        # Merge: keep new detection results but restore rules, boundaries, engine, max_retries
        python3 -c "
import yaml

with open('$dir/$RALPH_CONFIG_FILE') as f:
    new = yaml.safe_load(f)
with open('$old_config_tmp') as f:
    old = yaml.safe_load(f)

# Preserve customizations from old config
new['engine'] = old.get('engine', '$engine')
new['max_retries'] = old.get('max_retries', 3)
if old.get('rules'):
    new['rules'] = old['rules']
if old.get('boundaries', {}).get('never_touch'):
    new['boundaries'] = old['boundaries']
# Preserve old commands if new detection found nothing
old_cmds = old.get('commands') or {}
new_cmds = new.get('commands') or {}
merged_cmds = dict(old_cmds)
for k, v in (new_cmds or {}).items():
    if v:
        merged_cmds[k] = v
if merged_cmds:
    new['commands'] = merged_cmds

with open('$dir/$RALPH_CONFIG_FILE', 'w') as f:
    f.write('# vaibhav ralph configuration\n')
    f.write('# Auto-generated — edit as needed\n\n')
    yaml.dump(new, f, default_flow_style=False, sort_keys=False)
" 2>/dev/null
        rm -f "$old_config_tmp"
    else
        # First time — just set the chosen engine
        sed -i "s/^engine: .*/engine: \"$engine\"/" "$dir/$RALPH_CONFIG_FILE"
    fi

    echo -e "  ${GREEN}✓${NC} Config written to ${CYAN}${dir}/${RALPH_CONFIG_FILE}${NC}"
    if [[ -n "$existing_config" ]]; then
        echo -e "  ${DIM}(rules, boundaries, and engine preserved from existing config)${NC}"
    fi
    echo ""
    cat "$dir/$RALPH_CONFIG_FILE"
    echo ""
    echo -e "${BOLD}Next steps:${NC}"
    echo "  vaibhav ralph add-rule \"your rule here\"   Add project-specific rules"
    echo "  vaibhav ralph config                       Review config"
    echo "  vaibhav ralph prd create <name>            Write a PRD"
    echo "  vaibhav ralph run                          Start the ralph loop"
}

# --- Add rule ---
ralph_add_rule() {
    local rule="$1"
    local dir
    dir=$(find_config_dir)

    if [[ -z "$dir" ]]; then
        echo -e "${RED}Error:${NC} No .vaibhav/config.yaml found. Run 'vaibhav ralph init' first."
        exit 1
    fi

    local config="$dir/$RALPH_CONFIG_FILE"

    # Replace empty rules array or append to existing
    if grep -q '^rules: \[\]' "$config"; then
        sed -i "s/^rules: \[\]/rules:\n  - \"$rule\"/" "$config"
    else
        # Find the rules section and append
        sed -i "/^rules:/a\\  - \"$rule\"" "$config"
    fi

    echo -e "${GREEN}✓${NC} Added rule: ${CYAN}${rule}${NC}"
}

# --- Show config ---
ralph_config() {
    local dir
    dir=$(find_config_dir)

    if [[ -z "$dir" ]]; then
        echo -e "${RED}Error:${NC} No .vaibhav/config.yaml found. Run 'vaibhav ralph init' first."
        exit 1
    fi

    echo -e "${BOLD}vaibhav ralph config${NC} ${DIM}(${dir}/${RALPH_CONFIG_FILE})${NC}"
    echo ""
    cat "$dir/$RALPH_CONFIG_FILE"
}

# --- Status ---
ralph_status() {
    local dir
    dir=$(find_config_dir)

    if [[ -z "$dir" ]]; then
        echo -e "${RED}Error:${NC} No .vaibhav/config.yaml found. Run 'vaibhav ralph init' first."
        exit 1
    fi

    local prd="$dir/prd.json"
    if [[ ! -f "$prd" ]]; then
        echo -e "${YELLOW}No prd.json found.${NC} Run 'vaibhav ralph prd create <name>' to get started."
        return
    fi

    echo -e "${BOLD}Ralph Status${NC}"
    echo ""

    # Parse prd.json for progress
    python3 -c "
import json, sys
with open('$prd') as f:
    data = json.load(f)
project = data.get('project', 'unknown')
branch = data.get('branchName', '')
stories = data.get('userStories', [])
done = sum(1 for s in stories if s.get('passes'))
total = len(stories)
print(f'  Project:  $CYAN{project}$NC')
if branch:
    print(f'  Branch:   $DIM{branch}$NC')
print(f'  Progress: {done}/{total} stories complete')
print()
for s in stories:
    sid = s.get('id', '?')
    title = s.get('title', 'untitled')
    passed = s.get('passes', False)
    if passed:
        print(f'  $GREEN●$NC {sid}  {title}  $GREEN✓$NC')
    else:
        print(f'  $DIM○$NC {sid}  {title}')
" 2>/dev/null || echo -e "  ${RED}Error parsing prd.json${NC}"
}

# --- Find config dir (walk up from cwd) ---
find_config_dir() {
    local dir
    dir=$(pwd)
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/$RALPH_CONFIG_FILE" ]]; then
            echo "$dir"
            return
        fi
        dir=$(dirname "$dir")
    done
    echo ""
}

# --- Read config values ---
read_config_value() {
    local config="$1"
    local key="$2"
    python3 -c "
import yaml, sys
with open('$config') as f:
    data = yaml.safe_load(f)
keys = '$key'.split('.')
val = data
for k in keys:
    if val is None:
        break
    val = val.get(k)
if val is not None:
    if isinstance(val, list):
        for item in val:
            print(item)
    else:
        print(val)
" 2>/dev/null
}

# --- Resolve prompts dir ---
get_prompts_dir() {
    local script_path
    script_path="$(readlink -f "$0")"
    echo "$(dirname "$(dirname "$script_path")")/prompts"
}

# --- Build ralph prompt from template + config ---
build_prompt() {
    local dir="$1"
    local config="$dir/$RALPH_CONFIG_FILE"
    local prompts_dir
    prompts_dir=$(get_prompts_dir)
    local template="$prompts_dir/ralph-prompt.md"

    if [[ ! -f "$template" ]]; then
        echo -e "${RED}Error:${NC} Prompt template not found at $template"
        exit 1
    fi

    local prompt
    prompt=$(cat "$template")

    # Build project context
    local project_name language framework
    project_name=$(read_config_value "$config" "project.name")
    language=$(read_config_value "$config" "project.language")
    framework=$(read_config_value "$config" "project.framework")

    local context="Project: ${project_name}"
    [[ -n "$language" ]] && context+="\nLanguage: ${language}"
    [[ -n "$framework" ]] && context+="\nFramework: ${framework}"

    # Build rules
    local rules=""
    while IFS= read -r rule; do
        [[ -n "$rule" ]] && rules+="- ${rule}\n"
    done < <(read_config_value "$config" "rules")
    rules="${rules:-No project-specific rules defined.}"

    # Build boundaries
    local boundaries=""
    while IFS= read -r boundary; do
        [[ -n "$boundary" ]] && boundaries+="- ${boundary}\n"
    done < <(read_config_value "$config" "boundaries.never_touch")

    # Build commands
    local commands=""
    local cmd_test cmd_lint cmd_build cmd_typecheck
    cmd_test=$(read_config_value "$config" "commands.test")
    cmd_lint=$(read_config_value "$config" "commands.lint")
    cmd_build=$(read_config_value "$config" "commands.build")
    cmd_typecheck=$(read_config_value "$config" "commands.typecheck")
    [[ -n "$cmd_test" ]] && commands+="   - Test: \`${cmd_test}\`\n"
    [[ -n "$cmd_lint" ]] && commands+="   - Lint: \`${cmd_lint}\`\n"
    [[ -n "$cmd_build" ]] && commands+="   - Build: \`${cmd_build}\`\n"
    [[ -n "$cmd_typecheck" ]] && commands+="   - Typecheck: \`${cmd_typecheck}\`\n"
    commands="${commands:-   - Run whatever quality checks the project uses\n}"

    # Replace placeholders
    prompt="${prompt//\{\{PROJECT_CONTEXT\}\}/$context}"
    prompt="${prompt//\{\{RULES\}\}/$rules}"
    prompt="${prompt//\{\{BOUNDARIES\}\}/$boundaries}"
    prompt="${prompt//\{\{COMMANDS\}\}/$commands}"

    echo -e "$prompt"
}

# --- PRD commands ---
ralph_prd() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        create)
            ralph_prd_create "$@"
            ;;
        convert)
            ralph_prd_convert "$@"
            ;;
        list|ls)
            ralph_prd_list
            ;;
        ""|help|-h)
            echo -e "${BOLD}vaibhav ralph prd${NC} — PRD authoring"
            echo ""
            echo "  vaibhav ralph prd create <name> [\"desc\"]  Write a PRD with AI assistance"
            echo "  vaibhav ralph prd convert <file>   Convert markdown PRD to prd.json"
            echo "  vaibhav ralph prd list             List all PRDs"
            ;;
        *)
            echo -e "${RED}Unknown prd command:${NC} $subcmd"
            exit 1
            ;;
    esac
}

ralph_prd_create() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        echo -e "${RED}Usage:${NC} vaibhav ralph prd create <feature-name> [\"description of what to build\"]"
        exit 1
    fi
    local description="${2:-}"

    local dir
    dir=$(find_config_dir)
    if [[ -z "$dir" ]]; then
        echo -e "${RED}Error:${NC} No .vaibhav/config.yaml found. Run 'vaibhav ralph init' first."
        exit 1
    fi

    local config="$dir/$RALPH_CONFIG_FILE"
    local engine
    engine=$(read_config_value "$config" "engine")
    engine="${engine:-amp}"

    local prompts_dir
    prompts_dir=$(get_prompts_dir)
    local skill_file="$prompts_dir/prd-skill.md"

    if [[ ! -f "$skill_file" ]]; then
        echo -e "${RED}Error:${NC} PRD skill not found at $skill_file"
        exit 1
    fi

    # Create tasks dir
    mkdir -p "$dir/tasks"

    local skill_content
    skill_content=$(cat "$skill_file")

    local feature_section="## Feature to write PRD for: ${name}"
    if [[ -n "$description" ]]; then
        feature_section+="

### Description
${description}"
    fi

    local prompt="$skill_content

---

${feature_section}

Create a PRD for this feature. Save it to tasks/prd-${name}.md

Ask me clarifying questions first before writing the PRD."

    echo -e "${BOLD}vaibhav ralph prd create${NC}"
    echo -e "  Feature:  ${CYAN}${name}${NC}"
    [[ -n "$description" ]] && echo -e "  Desc:     ${CYAN}${description}${NC}"
    echo -e "  Engine:   ${CYAN}${engine}${NC}"
    echo -e "  Output:   ${CYAN}tasks/prd-${name}.md${NC}"
    echo ""

    case "$engine" in
        amp)
            echo "$prompt" | amp --dangerously-allow-all 2>&1
            ;;
        claude)
            echo "$prompt" | claude --dangerously-skip-permissions --print 2>&1
            ;;
        opencode)
            echo "$prompt" | opencode 2>&1
            ;;
        *)
            echo -e "${RED}Error:${NC} Unknown engine '$engine'"
            exit 1
            ;;
    esac

    if [[ -f "$dir/tasks/prd-${name}.md" ]]; then
        echo ""
        echo -e "${GREEN}✓${NC} PRD saved to ${CYAN}tasks/prd-${name}.md${NC}"
        echo -e "  Next: ${DIM}vaibhav ralph prd convert tasks/prd-${name}.md${NC}"
    fi
}

ralph_prd_convert() {
    local file="${1:-}"
    if [[ -z "$file" ]]; then
        echo -e "${RED}Usage:${NC} vaibhav ralph prd convert <prd-file.md>"
        exit 1
    fi

    local dir
    dir=$(find_config_dir)
    if [[ -z "$dir" ]]; then
        echo -e "${RED}Error:${NC} No .vaibhav/config.yaml found. Run 'vaibhav ralph init' first."
        exit 1
    fi

    # Resolve relative path from project root
    if [[ ! "$file" = /* ]]; then
        file="$dir/$file"
    fi

    if [[ ! -f "$file" ]]; then
        echo -e "${RED}Error:${NC} File not found: $file"
        exit 1
    fi

    local config="$dir/$RALPH_CONFIG_FILE"
    local engine
    engine=$(read_config_value "$config" "engine")
    engine="${engine:-amp}"

    local prompts_dir
    prompts_dir=$(get_prompts_dir)
    local convert_file="$prompts_dir/prd-convert.md"

    if [[ ! -f "$convert_file" ]]; then
        echo -e "${RED}Error:${NC} Convert prompt not found at $convert_file"
        exit 1
    fi

    local prd_content
    prd_content=$(cat "$file")

    local convert_prompt
    convert_prompt=$(cat "$convert_file")

    local prompt="$convert_prompt

---

## PRD to convert:

$prd_content

---

Write the output to prd.json in the project root."

    echo -e "${BOLD}vaibhav ralph prd convert${NC}"
    echo -e "  Input:   ${CYAN}${file}${NC}"
    echo -e "  Engine:  ${CYAN}${engine}${NC}"
    echo -e "  Output:  ${CYAN}prd.json${NC}"
    echo ""

    case "$engine" in
        amp)
            echo "$prompt" | amp --dangerously-allow-all 2>&1
            ;;
        claude)
            echo "$prompt" | claude --dangerously-skip-permissions --print 2>&1
            ;;
        opencode)
            echo "$prompt" | opencode 2>&1
            ;;
        *)
            echo -e "${RED}Error:${NC} Unknown engine '$engine'"
            exit 1
            ;;
    esac

    if [[ -f "$dir/prd.json" ]]; then
        echo ""
        echo -e "${GREEN}✓${NC} prd.json created"
        echo -e "  Next: ${DIM}vaibhav ralph run${NC}"
    fi
}

ralph_prd_list() {
    local dir
    dir=$(find_config_dir)
    if [[ -z "$dir" ]]; then
        echo -e "${RED}Error:${NC} No .vaibhav/config.yaml found. Run 'vaibhav ralph init' first."
        exit 1
    fi

    echo -e "${BOLD}PRDs${NC}"
    echo ""

    if [[ ! -d "$dir/tasks" ]] || ! ls "$dir"/tasks/prd-*.md &>/dev/null; then
        echo -e "  ${DIM}No PRDs found. Run 'vaibhav ralph prd create <name>'${NC}"
        return
    fi

    for prd_file in "$dir"/tasks/prd-*.md; do
        local name
        name=$(basename "$prd_file" .md | sed 's/^prd-//')
        local stories
        stories=$(grep -c '### US-' "$prd_file" 2>/dev/null || echo "0")
        echo -e "  ${CYAN}${name}${NC} ${DIM}(${stories} stories)${NC} → ${DIM}${prd_file}${NC}"
    done

    echo ""

    # Show prd.json status if exists
    if [[ -f "$dir/prd.json" ]]; then
        local done total
        done=$(python3 -c "
import json
with open('$dir/prd.json') as f:
    data = json.load(f)
stories = data.get('userStories', [])
print(sum(1 for s in stories if s.get('passes')))
" 2>/dev/null || echo "?")
        total=$(python3 -c "
import json
with open('$dir/prd.json') as f:
    data = json.load(f)
print(len(data.get('userStories', [])))
" 2>/dev/null || echo "?")
        echo -e "  ${BOLD}Active prd.json:${NC} ${done}/${total} stories complete"
    fi
}

# --- Run command (the ralph loop) ---
ralph_run() {
    local dir
    dir=$(find_config_dir)
    if [[ -z "$dir" ]]; then
        echo -e "${RED}Error:${NC} No .vaibhav/config.yaml found. Run 'vaibhav ralph init' first."
        exit 1
    fi

    local config="$dir/$RALPH_CONFIG_FILE"
    local engine max_iterations single_task dry_run no_tmux
    engine=$(read_config_value "$config" "engine")
    engine="${engine:-amp}"
    max_iterations=10
    single_task=""
    dry_run=false
    no_tmux=false

    # Parse args
    local run_args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --engine)
                engine="$2"
                run_args+=("$1" "$2")
                shift 2
                ;;
            --max-iterations)
                max_iterations="$2"
                run_args+=("$1" "$2")
                shift 2
                ;;
            --dry-run)
                dry_run=true
                run_args+=("$1")
                shift
                ;;
            --no-tmux)
                no_tmux=true
                shift
                ;;
            *)
                # Treat as single task description
                single_task="$1"
                run_args+=("$1")
                shift
                ;;
        esac
    done

    # Launch inside tmux unless --no-tmux, --dry-run, or already inside the ralph tmux session
    if [[ "$no_tmux" == "false" && "$dry_run" == "false" ]]; then
        local project_name
        project_name=$(read_config_value "$config" "project.name")
        project_name="${project_name:-$(basename "$dir")}"
        local session_name="ralph-${project_name}"

        # If already inside this ralph tmux session, continue without re-wrapping
        if [[ "${VAIBHAV_RALPH_TMUX:-}" != "$session_name" ]]; then
            if tmux has-session -t "$session_name" 2>/dev/null; then
                echo -e "${BOLD}Ralph is already running${NC} in tmux session ${CYAN}${session_name}${NC}"
                echo -e "  Attach with: ${CYAN}tmux attach -t ${session_name}${NC}"
                echo ""
                read -rp "Attach to existing session? [Y/n] " yn
                if [[ "$yn" =~ ^[Nn]$ ]]; then
                    return
                fi
                if [[ -n "${TMUX:-}" ]]; then
                    tmux switch-client -t "$session_name"
                else
                    tmux attach-session -t "$session_name"
                fi
                return
            fi

            # Build the command to re-exec inside tmux
            local tmux_cmd
            tmux_cmd="cd $(printf '%q' "$dir") && VAIBHAV_RALPH_TMUX=$(printf '%q' "$session_name") $(printf '%q' "$0") run --no-tmux"
            for arg in "${run_args[@]+"${run_args[@]}"}"; do
                tmux_cmd+=" $(printf '%q' "$arg")"
            done

            echo -e "${DIM}Starting ralph in tmux session: ${session_name}${NC}"
            tmux new-session -d -s "$session_name" -c "$dir" bash -c "$tmux_cmd"

            # Attach to the session
            if [[ -n "${TMUX:-}" ]]; then
                tmux switch-client -t "$session_name"
            else
                tmux attach-session -t "$session_name"
            fi
            return
        fi
    fi

    # Single task mode (no PRD needed)
    if [[ -n "$single_task" ]]; then
        ralph_run_single "$dir" "$engine" "$single_task"
        return
    fi

    # PRD loop mode
    local prd="$dir/prd.json"
    if [[ ! -f "$prd" ]]; then
        echo -e "${RED}Error:${NC} No prd.json found."
        echo -e "  Create one with: ${CYAN}vaibhav ralph prd create <name>${NC}"
        echo -e "  Then convert:    ${CYAN}vaibhav ralph prd convert tasks/prd-<name>.md${NC}"
        exit 1
    fi

    local progress="$dir/progress.txt"
    local archive_dir="$dir/archive"
    local last_branch_file="$dir/.vaibhav/.last-branch"

    # Archive previous run if branch changed
    if [[ -f "$last_branch_file" ]]; then
        local current_branch last_branch
        current_branch=$(python3 -c "import json; print(json.load(open('$prd')).get('branchName',''))" 2>/dev/null || echo "")
        last_branch=$(cat "$last_branch_file" 2>/dev/null || echo "")

        if [[ -n "$current_branch" && -n "$last_branch" && "$current_branch" != "$last_branch" ]]; then
            local date_str folder_name archive_folder
            date_str=$(date +%Y-%m-%d)
            folder_name=$(echo "$last_branch" | sed 's|^ralph/||')
            archive_folder="$archive_dir/$date_str-$folder_name"

            echo -e "  ${DIM}Archiving previous run: ${last_branch}${NC}"
            mkdir -p "$archive_folder"
            [[ -f "$prd" ]] && cp "$prd" "$archive_folder/"
            [[ -f "$progress" ]] && cp "$progress" "$archive_folder/"

            echo "# Ralph Progress Log" > "$progress"
            echo "Started: $(date)" >> "$progress"
            echo "---" >> "$progress"
        fi
    fi

    # Track current branch
    local current_branch
    current_branch=$(python3 -c "import json; print(json.load(open('$prd')).get('branchName',''))" 2>/dev/null || echo "")
    if [[ -n "$current_branch" ]]; then
        mkdir -p "$(dirname "$last_branch_file")"
        echo "$current_branch" > "$last_branch_file"
    fi

    # Initialize progress file
    if [[ ! -f "$progress" ]]; then
        echo "# Ralph Progress Log" > "$progress"
        echo "Started: $(date)" >> "$progress"
        echo "---" >> "$progress"
    fi

    # Build the prompt
    local prompt
    prompt=$(build_prompt "$dir")

    if [[ "$dry_run" == "true" ]]; then
        echo -e "${BOLD}vaibhav ralph run ${DIM}(dry run)${NC}"
        echo -e "  Project:     ${CYAN}$(read_config_value "$config" "project.name")${NC}"
        echo -e "  Engine:      ${CYAN}${engine}${NC}"
        echo -e "  Iterations:  ${CYAN}${max_iterations}${NC}"
        echo -e "  PRD:         ${CYAN}${prd}${NC}"
        echo ""
        echo -e "${BOLD}Prompt that would be sent:${NC}"
        echo "---"
        echo "$prompt"
        echo "---"
        return
    fi

    echo -e "${BOLD}vaibhav ralph run${NC}"
    echo -e "  Project:     ${CYAN}$(read_config_value "$config" "project.name")${NC}"
    echo -e "  Engine:      ${CYAN}${engine}${NC}"
    echo -e "  Iterations:  ${CYAN}max ${max_iterations}${NC}"
    echo ""

    for i in $(seq 1 "$max_iterations"); do
        echo ""
        echo "==============================================================="
        echo "  Ralph Iteration $i of $max_iterations ($engine)"
        echo "==============================================================="

        local output=""
        case "$engine" in
            amp)
                output=$(echo "$prompt" | amp --dangerously-allow-all 2>&1 | tee /dev/stderr) || true
                ;;
            claude)
                output=$(echo "$prompt" | claude --dangerously-skip-permissions --print 2>&1 | tee /dev/stderr) || true
                ;;
            opencode)
                output=$(echo "$prompt" | opencode 2>&1 | tee /dev/stderr) || true
                ;;
            *)
                echo -e "${RED}Error:${NC} Unknown engine '$engine'"
                exit 1
                ;;
        esac

        # Check for completion signal
        if echo "$output" | grep -q "<promise>COMPLETE</promise>"; then
            echo ""
            echo -e "${GREEN}${BOLD}Ralph completed all tasks!${NC}"
            echo "Completed at iteration $i of $max_iterations"
            return
        fi

        echo "Iteration $i complete. Continuing..."
        sleep 2
    done

    echo ""
    echo -e "${YELLOW}Ralph reached max iterations ($max_iterations) without completing all tasks.${NC}"
    echo -e "Check ${CYAN}progress.txt${NC} for status, or run again with more iterations."
}

# --- Single task mode ---
ralph_run_single() {
    local dir="$1"
    local engine="$2"
    local task="$3"
    local config="$dir/$RALPH_CONFIG_FILE"

    local context=""
    local language framework
    language=$(read_config_value "$config" "project.language")
    framework=$(read_config_value "$config" "project.framework")
    [[ -n "$language" ]] && context+="Language: ${language}. "
    [[ -n "$framework" ]] && context+="Framework: ${framework}. "

    local rules=""
    while IFS= read -r rule; do
        [[ -n "$rule" ]] && rules+="- ${rule}\n"
    done < <(read_config_value "$config" "rules")

    local prompt="You are a coding agent. Complete this task:

## Task
${task}

## Project Context
${context}
"
    [[ -n "$rules" ]] && prompt+="
## Rules
$(echo -e "$rules")
"
    prompt+="
## Instructions
1. Implement the task
2. Run quality checks (tests, lint, typecheck as applicable)
3. Commit with a descriptive message
4. Keep changes focused and minimal"

    echo -e "${BOLD}vaibhav ralph run${NC} ${DIM}(single task)${NC}"
    echo -e "  Task:    ${CYAN}${task}${NC}"
    echo -e "  Engine:  ${CYAN}${engine}${NC}"
    echo ""

    case "$engine" in
        amp)
            echo "$prompt" | amp --dangerously-allow-all 2>&1
            ;;
        claude)
            echo "$prompt" | claude --dangerously-skip-permissions --print 2>&1
            ;;
        opencode)
            echo "$prompt" | opencode 2>&1
            ;;
        *)
            echo -e "${RED}Error:${NC} Unknown engine '$engine'"
            exit 1
            ;;
    esac
}

# --- Help ---
ralph_help() {
    echo -e "${BOLD}vaibhav ralph${NC} — Ralph loop utility for AI-driven development"
    echo ""
    echo -e "${BOLD}Setup:${NC}"
    echo "  vaibhav ralph init [dir]           Auto-detect project and create .vaibhav/config.yaml"
    echo "  vaibhav ralph config               Show current project config"
    echo "  vaibhav ralph add-rule \"rule\"       Add a rule to the project config"
    echo ""
    echo -e "${BOLD}PRD:${NC}"
    echo "  vaibhav ralph prd create <name> [\"desc\"]  Write a PRD with AI assistance"
    echo "  vaibhav ralph prd convert <file>   Convert markdown PRD to prd.json"
    echo "  vaibhav ralph prd list             List all PRDs and progress"
    echo ""
    echo -e "${BOLD}Run:${NC}"
    echo "  vaibhav ralph run                  Start the ralph loop (uses prd.json)"
    echo "  vaibhav ralph run \"fix the bug\"    Single task mode (no PRD needed)"
    echo "  vaibhav ralph run --dry-run        Preview the prompt without executing"
    echo "  vaibhav ralph run --engine claude   Override AI engine"
    echo "  vaibhav ralph run --max-iterations 5"
    echo "  vaibhav ralph run --no-tmux        Run directly without tmux wrapping"
    echo "  vaibhav ralph status               Show PRD progress"
    echo ""
    echo -e "${BOLD}Options:${NC}"
    echo "  -p, --project <name>         Target a registered project (for remote use)"
    echo ""
    echo -e "${BOLD}Workflow:${NC}"
    echo "  1. vaibhav ralph init              Setup project config"
    echo "  2. vaibhav ralph prd create auth \"Add login with email/password\"  Write a PRD"
    echo "  3. vaibhav ralph prd convert tasks/prd-auth.md"
    echo "  4. vaibhav ralph run               Start the loop"
    echo ""
    echo -e "${BOLD}From phone:${NC}"
    echo "  vaibhav ralph -p heimdall status"
    echo "  vaibhav ralph -p heimdall run --max-iterations 3"
}

# --- Main dispatch ---
case "${1:-}" in
    ""|help|-h|--help)
        ralph_help
        ;;
    init)
        ralph_init "${2:-}"
        ;;
    config)
        ralph_config
        ;;
    add-rule)
        if [[ $# -lt 2 ]]; then
            echo -e "${RED}Usage:${NC} vaibhav ralph add-rule \"your rule here\""
            exit 1
        fi
        ralph_add_rule "$2"
        ;;
    prd)
        shift
        ralph_prd "$@"
        ;;
    run)
        shift
        ralph_run "$@"
        ;;
    status)
        ralph_status
        ;;
    *)
        echo -e "${RED}Unknown command:${NC} $1"
        echo ""
        ralph_help
        exit 1
        ;;
esac
